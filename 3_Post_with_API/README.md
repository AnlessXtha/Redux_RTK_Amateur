# Code Explained (3_Post_with_API)

# Used Concepts

## @reduxjs/toolkit (createAsyncThunk, nanoid)

- ## createAsyncThunk

  `createAsyncThunk` is a function provided by the Redux Toolkit, a library that simplifies Redux usage. This function helps streamline the process of handling asynchronous actions in Redux. It creates an action creator that generates three action types: pending, fulfilled, and rejected. These correspond to the different stages of an asynchronous operation (e.g., API call). It allows developers to write asynchronous logic in a more organized and readable way by separating the handling of asynchronous actions into a single thunk. This enhances code maintainability and reduces boilerplate code in Redux applications.

  ### Purpose:

  The primary purpose of `createAsyncThunk` is to simplify the process of dealing with asynchronous actions in a Redux application. It helps manage the boilerplate code associated with asynchronous operations and enhances code readability.

  ### Syntax:

        createAsyncThunk(typePrefix, payloadCreator, options)

  - typePrefix (string): A string that serves as the prefix for the three action types generated by `createAsyncThunk`.

  - payloadCreator (function): A function that returns a `Promise`. This function is responsible for the asynchronous logic and resolving or rejecting the Promise which will determine the outcome of the action.

  - options (object): An optional object that allows you to configure various aspects of the async thunk, such as conditionally dispatching actions, serializing arguments, or defining extraReducers.

  ### Example:

        import { createAsyncThunk } from '@reduxjs/toolkit';

        const fetchUserData = createAsyncThunk('user/fetchUserData', async (userId, thunkAPI) => {
            const response = await fetch(`https://api.example.com/users/${userId}`);
            return response.json();
        });

  ### Actions Types Generated:

  `createAsyncThunk` automatically generates three action types based on the provided `typePrefix`:

  - `${typePrefix}/pending`: This is dispatched when the async operation begins.
  - `${typePrefix}/fulfilled`: Dispatched when the async operation is successful. The result of the operation is included in the action payload.
  - `${typePrefix}/rejected`: Dispatched when the async operation fails. The error is included in the action payload.

  ### Usage in Reducers:

  To handle the actions generated by `createAsyncThunk`, you can use the `extraReducers` field when creating a slice with `createSlice` from Redux Toolkit.

  For example:

        import { createSlice } from '@reduxjs/toolkit';

        const userSlice = createSlice({
            name: 'user',
            initialState: { data: null, status: 'idle', error: null },
            reducers: {},
            extraReducers: (builder) => {
                builder
                .addCase(fetchUserData.pending, (state) => {
                    state.status = 'loading';
                })
                .addCase(fetchUserData.fulfilled, (state, action) => {
                    state.status = 'succeeded';
                    state.data = action.payload;
                })
                .addCase(fetchUserData.rejected, (state, action) => {
                    state.status = 'failed';
                    state.error = action.error.message;
                });
            },
        });

  ### Benefits:

  - Boilerplate Reduction: `createAsyncThunk` significantly reduces the boilerplate code associated with asynchronous actions, making the codebase more concise and readable.

  - Simplified Async Logic: The separation of async logic into a dedicated thunk function enhances the clarity of code and simplifies error handling.

  - Automatic Action Type Generation: The three action types (pending, fulfilled, rejected) are automatically generated, reducing the likelihood of naming conflicts.

  In summary, `createAsyncThunk` is a powerful utility function that simplifies the handling of asynchronous operations in Redux applications, providing a clean and organized way to manage complex async logic.

- ## nanoid

  `nanoid` is a small, fast, and secure library for generating unique identifiers (IDs) composed of random characters. It's often used in scenarios where you need a short, URL-safe, and collision-resistant identifier, such as for generating unique keys in databases or creating unique URLs.

  ### Key Features:

  1. Size and Format:

  - `nanoid` generates IDs with a default size of 21 characters.
  - The IDs are URL-safe, meaning they can be used in URLs without encoding issues.

  2. Randomness:

  - IDs are generated using a combination of timestamp and random characters, providing a good level of unpredictability.
  - The randomness is achieved using the `crypto` library in Node.js environments and `window.crypto` in browsers.

  3. Collision Resistance:

  - The probability of collision (two IDs being the same) is extremely low due to the combination of timestamp and randomness.

  4. Customization:

  - You can customize the ID size and character set by passing options to the `nanoid` function.

  ### Usage:

  1. Installation:

     npm install nanoid

  2. Basic Usage:

     const { nanoid } = require('nanoid');

     const id = nanoid(); // Generates a default 21-character ID

  3. Customization:

     const customLength = 10;
     const customAlphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';

     const customId = nanoid(customLength, customAlphabet);

  ### Example:

          const { nanoid } = require('nanoid');

          const id1 = nanoid(); // e.g., "lLkpRMrBqLQqt7b77Lhx6"
          const id2 = nanoid(10); // e.g., "Sj9rnkX9Ii"

  ### Security Considerations:

  - `nanoid` uses the `crypto` library in Node.js, which is considered secure for cryptographic operations.
  - In browsers, `window.crypto` is used if available.
  - The randomness and collision resistance of `nanoid` make it suitable for generating unique identifiers, but it should not be used for cryptographic purposes where high entropy is critical.

  ### Alternatives:

  - While `nanoid` is suitable for many use cases, there are other libraries like `uuid` that generate universally unique identifiers (UUIDs) following the UUID standard.

  In summary, `nanoid` is a lightweight and efficient library for generating unique, URL-safe identifiers with a focus on speed, security, and collision resistance. Its simplicity and customization options make it a popular choice for various applications where unique IDs are needed.

## date-fns(sub, parseISO, formatDistanceToNow)

`date-fns` is a popular JavaScript library for working with dates. It provides a set of functions to manipulate, format, and parse dates in a simple and efficient way. Here's an explanation of three specific functions from `date-fns`: `sub`, `parseISO`, and `formatDistanceToNow`.

### 1. sub Function:

Purpose:

The `sub` function is used to subtract a specified duration (such as days, months, or years) from a given date.

Syntax:

    import { sub } from 'date-fns';

    const newDate = sub(originalDate, { unit: 'days', amount: 7 });

Example:

    import { sub } from 'date-fns';

    const currentDate = new Date();
    const oneWeekAgo = sub(currentDate, { unit: 'days', amount: 7 });

### 2. parseISO Function:

Purpose:

The `parseISO` function is used to parse a string representing a date in ISO 8601 format and convert it into a JavaScript `Date` object.

Syntax:

    import { parseISO } from 'date-fns';

    const parsedDate = parseISO('2023-01-01T12:00:00Z');

Example:

    import { parseISO } from 'date-fns';

    const dateString = '2023-01-01T12:00:00Z';
    const parsedDate = parseISO(dateString);

### 3. formatDistanceToNow Function:

Purpose:

The `formatDistanceToNow` function is used to format the difference between a given date and the current date in a human-readable format, such as "2 days ago" or "in 3 months."

Syntax:

    import { formatDistanceToNow } from 'date-fns';

    const distance = formatDistanceToNow(date);

Example:

    import { formatDistanceToNow } from 'date-fns';

    const pastDate = sub(new Date(), { unit: 'days', amount: 7 });
    const distance = formatDistanceToNow(pastDate);
    // Output: "7 days ago"

### Overall Usage:

    import { sub, parseISO, formatDistanceToNow } from 'date-fns';

    const currentDate = new Date();
    const oneWeekAgo = sub(currentDate, { unit: 'days', amount: 7 });

    const dateString = '2023-01-01T12:00:00Z';
    const parsedDate = parseISO(dateString);

    const distance = formatDistanceToNow(parsedDate);
    // Output: "in 2 years" (depending on the current date)

In summary, `date-fns` provides a comprehensive set of functions for handling dates in JavaScript. The `sub` function is used for subtracting durations, `parseISO` for parsing ISO 8601 date strings, and `formatDistanceToNow` for presenting the time difference between a given date and the current date in a human-readable format. These functions collectively make working with dates in JavaScript more straightforward and efficient.

## axios(In General)

axios is a popular JavaScript library that is used to make HTTP requests from web browsers and Node.js environments. It simplifies the process of sending asynchronous HTTP requests and handling responses. axios supports Promises, allowing for a clean and flexible way to interact with RESTful APIs or perform other HTTP-related tasks.

1.  Installation:
    You can install axios using npm or yarn:

        npm install axios


        yar add axios

2.  Basic Usage:
    // Importing axios in a Node.js environment
    const axios = require('axios');

        // Making a GET request
        axios.get('https://api.example.com/data')
        .then(response => {
            console.log(response.data);
        })
        .catch(error => {
            console.error(error);
        });

3.  Promise-Based:
    `axios` is built on Promises, allowing you to use `.then()` and `.catch()` to handle asynchronous operations.

4.  Request Methods:
    `axios` supports various HTTP request methods, including GET, POST, PUT, DELETE, etc. Each method is available as a function (e.g., `axios.get()`, `axios.post()`).

5.  Configurable:
    You can configure requests by passing an options object. This includes headers, request data, timeout, and more.

6.  Interceptors:
    Interceptors allow you to run your code or modify the request/response before the request is sent or after the response is received.

7.  Concurrent Requests:
    `axios` supports concurrent requests using `axios.all()` and `axios.spread()`. These functions make it easy to handle multiple asynchronous requests simultaneously.

8.  Canceling Requests:
    `axios` supports canceling requests using a cancel token. This can be useful for scenarios where a user navigates away from a page, and you want to cancel any ongoing requests.

9.  Error Handling:
    Errors are automatically thrown for unsuccessful HTTP responses (status codes outside the range of 2xx). You can catch these errors in the `.catch()` block.

10. Response Transformations:
    You can define functions to transform the response data or request data before it is sent or after it is received.

    Example:

        const axios = require('axios');

        // Making a POST request with data
        axios.post('https://api.example.com/post', { data: 'some data' })
        .then(response => {
            console.log(response.data);
        })
        .catch(error => {
            console.error(error);
        });

    Using axios in a Browser Environment:

        <!-- Include axios via CDN in your HTML file -->
        <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>

        <script>
        // Making a GET request in the browser
        axios.get('https://api.example.com/data')
            .then(response => {
            console.log(response.data);
            })
            .catch(error => {
            console.error(error);
            });
        </script>

In summary, axios is a versatile and powerful library for making HTTP requests in JavaScript applications. Its simplicity, flexibility, and support for promises make it a popular choice for developers working with APIs or performing other HTTP-related tasks in both browser and Node.js environments.

## axios(In React/Redux)

In a React/Redux application, `axios` is often used for making asynchronous HTTP requests, such as fetching data from a server or interacting with APIs. When integrated with Redux, `axios` can be used within action creators to perform asynchronous operations, and the retrieved data can be dispatched to the Redux store. Below is a detailed explanation of how `axios` is commonly used in a React/Redux setup:

1.  Installation:
    Install `axios` in your React/Redux project:

        npm install axios

2.  Setting up an Action Creator:
    Create a Redux action creator that uses `axios` to make an asynchronous request. This action creator can be triggered by a component or another part of your application.

        javascript(actions.js)

            import axios from 'axios';

            export const fetchData = () => {
                return async (dispatch) => {
                try {
                    // Dispatch a loading action before making the request
                    dispatch({ type: 'FETCH_DATA_REQUEST' });

                    // Make the asynchronous request using axios
                    const response = await axios.get('https://api.example.com/data');

                    // Dispatch a success action with the retrieved data
                    dispatch({ type: 'FETCH_DATA_SUCCESS', payload: response.data });
                    } catch (error) {
                        // Dispatch an error action if the request fails
                        dispatch({ type: 'FETCH_DATA_FAILURE', payload: error.message });
                    }

                };
            };

3.  Redux Reducer:

    Create a Redux reducer to handle the dispatched actions and update the state accordingly.

    javascript(reducer.js)

        const initialState = {
            data: [],
            loading: false,
            error: null,
        };

        const dataReducer = (state = initialState, action) => {
            switch (action.type) {
                case 'FETCH_DATA_REQUEST':
                    return { ...state, loading: true, error: null };
                case 'FETCH_DATA_SUCCESS':
                    return { ...state, loading: false, data: action.payload };
                case 'FETCH_DATA_FAILURE':
                    return { ...state, loading: false, error: action.payload };
                default:
                    return state;
            }
        };

        export default dataReducer;

4.  Redux Store Configuration:

    Integrate the reducer into your Redux store configuration.

    javascript(store.js)

        import { createStore, applyMiddleware } from 'redux';
        import thunkMiddleware from 'redux-thunk';
        import dataReducer from './reducer';

        const store = createStore(dataReducer, applyMiddleware(thunkMiddleware));

        export default store;

5.  React Component:
    Connect your React component to the Redux store and dispatch the action.

    javascript (MyComponent.js)

        import React, { useEffect } from 'react';
        import { useDispatch, useSelector } from 'react-redux';
        import { fetchData } from './actions';

        const MyComponent = () => {
            const dispatch = useDispatch();
            const { data, loading, error } = useSelector((state) => state);

            useEffect(() => {
                // Dispatch the fetchData action when the component mounts
                dispatch(fetchData());
            }, [dispatch]);

            if (loading) {
                return <div>Loading...</div>;
            }

            if (error) {
                return <div>Error: {error}</div>;
            }

            return (
                <div>
                    {/_ Display the fetched data in your component _/}
                    {data.map((item) => (
                        <div key={item.id}>{item.name}</div>
                    ))}
                </div>
            );
        };

        export default MyComponent;

In summary, `axios` can be seamlessly integrated into a React/Redux application to handle asynchronous operations, such as fetching data from APIs. Action creators using `axios` are often combined with Redux Thunk middleware to enable asynchronous actions. The retrieved data is then dispatched to the Redux store, and connected React components can access and display this data through the Redux store.

## extraReducers(builder)

In React/Redux, the `extraReducers` field is a part of the `createSlice` function provided by the Redux Toolkit. It is used to define additional reducer logic outside the standard `reducers` field. This allows developers to **handle actions dispatched by other slices or external actions without directly modifying the reducer logic within the original slice**. The `extraReducers` field takes a callback function (`builder`), and this function is used to define extra reducer logic.

Here's a detailed explanation:

1.  Basic `createSlice` Structure:

    When you use `createSlice` to define a Redux slice, the basic structure includes `name`, `initialState`, `reducers`, and `extraReducers`:

        import { createSlice } from '@reduxjs/toolkit';

        const mySlice = createSlice({
            name: 'mySliceName',
            initialState: {/* initial state */},
            reducers: {
                // standard reducers go here
            },
            extraReducers: (builder) => {
                // extra reducer logic goes here
            },
        });

2.  Understanding the builder Parameter:

    The `builder` parameter in the `extraReducers` function is an object that provides methods for defining additional reducer logic. These methods correspond to different action types and allow you to handle actions dispatched by other slices or external actions.

3.  Defining Extra Reducer Logic:

    Inside the `extraReducers` callback, you can use methods provided by the `builder` object to define how the slice's state should be updated in response to specific actions. The most commonly used methods include:

    - `addCase`: Handles a specific action type.
    - `addMatcher`: Handles actions based on a custom matcher function.
    - `addDefaultCase`: Handles any action type not explicitly handled by other methods.

      extraReducers: (builder) => {
      builder
      .addCase(someOtherSliceAction, (state, action) => {
      // Handle the action and update the state
      })
      .addMatcher(
      (action) => action.type.endsWith('/fulfilled'),
      (state, action) => {
      // Handle actions that end with '/fulfilled'
      }
      )
      .addDefaultCase((state, action) => {
      // Handle any other action type not explicitly handled
      });
      },

4.  Example: Handling Actions from Another Slice:

    Let's say you have two slices, `sliceA` and `sliceB`, and you want `sliceA` to respond to an action dispatched by `sliceB`. You can use `extraReducers` in `sliceA`:

        // sliceA.js
        import { createSlice } from '@reduxjs/toolkit';
        import { someActionFromSliceB } from './sliceB';

        const sliceA = createSlice({
        name: 'sliceA',
        initialState: {/* initial state */},
        reducers: {
            // standard reducers go here
        },
        extraReducers: (builder) => {
            builder
            .addCase(someActionFromSliceB, (state, action) => {
                // Handle the action from sliceB
            });
        },
        });

        export default sliceA;

        // sliceB.js
        import { createSlice } from '@reduxjs/toolkit';

        const sliceB = createSlice({
        name: 'sliceB',
        initialState: {/* initial state */},
        reducers: {
            // standard reducers go here
        },
        });

        export const { someActionFromSliceB } = sliceB.actions;
        export default sliceB;

5.  Benefits of `extraReducers`:

    - Separation of Concerns: It allows you to keep the logic for handling actions from other slices or external actions separate from the main `reducers` field, promoting a cleaner and more modular code structure.

    - Reusability: You can import and reuse actions from other slices without modifying the original slice's code.

In summary, `extraReducers` in React/Redux, specifically in the context of `createSlice`, provides a way to handle actions from other slices or external actions. It allows for a clean separation of concerns and promotes modularity in Redux code. Developers can define additional reducer logic outside the main `reducers` field, making it easier to manage and extend Redux slices.

## .unwrap() function

- Throws an error and let us go to the catch block if an error is occurs.
- It lets the promise either reject or create an error and then represents that and allows us to use try catch logic.

# Code Explained

## Code

import { createSlice, nanoid, createAsyncThunk } from "@reduxjs/toolkit";
import { sub } from "date-fns";
import axios from "axios";

const POSTS_URL = "https://jsonplaceholder.typicode.com/posts";

const initialState = {
posts: [],
status: "idle", //'idle' | 'loading' | 'succeeded' | 'failed'
error: null,
};

export const fetchPosts = createAsyncThunk("posts/fetchPosts", async () => {
const response = await axios.get(POSTS_URL);
return [...response.data];
});

export const addNewPost = createAsyncThunk(
"posts/addNewPost",
async (initialPost) => {
try {
const response = await axios.post(POSTS_URL, initialPost);
return response.data;
} catch (err) {
return err.message;
}
}
);

const postsSlice = createSlice({
name: "posts",
initialState,
reducers: {
postAdded: {
reducer(state, action) {
state.posts.push(action.payload);
},
prepare(title, content, userId) {
return {
payload: {
id: nanoid(),
title,
content,
date: new Date().toISOString(),
userId,
reactions: {
thumbsUp: 0,
wow: 0,
heart: 0,
rocket: 0,
coffee: 0,
},
},
};
},
},
reactionAdded(state, action) {
const { postId, reaction } = action.payload;
const existingPost = state.posts.find((post) => post.id === postId);
if (existingPost) {
existingPost.reactions[reaction]++;
}
},
},

extraReducers(builder) {
builder
.addCase(fetchPosts.pending, (state, action) => {
state.status = "loading";
})
.addCase(fetchPosts.fulfilled, (state, action) => {
state.status = "succeeded";
//Adding data and reactions
let min = 1;
const loadedPosts = action.payload.map((post) => {
post.date = sub(new Date(), { minutes: min++ }).toISOString();
post.reactions = {
thumbsUp: 0,
wow: 0,
heart: 0,
rocket: 0,
coffee: 0,
};
return post;
});
// Add any fetched posts to the array
state.posts = state.posts.concat(loadedPosts);
})
.addCase(fetchPosts.rejected, (state, action) => {
state.status = "failed";
state.error = action.error.message;
})
.addCase(addNewPost.fulfilled, (state, action) => {
// Fix for API post IDs:
// Creating sortedPosts & assigning the id
// would not be needed if the fake API
// returned accurate new post IDs
const sortedPosts = state.posts.sort((a, b) => {
if (a.id > b.id) return 1;
if (a.id < b.id) return -1;
return 0;
});
action.payload.id = sortedPosts[sortedPosts.length - 1].id + 1;
//End fix for fake API post IDs

        action.payload.userId = Number(action.payload.userId);
        action.payload.date = new Date().toISOString();
        action.payload.reactions = {
          thumbsUp: 0,
          wow: 0,
          heart: 0,
          rocket: 0,
          coffee: 0,
        };
        console.log(action.payload);
        state.posts.push(action.payload);
      });

},
});

export const selectAllPosts = (state) => state.posts.posts;
export const getPostsStatus = (state) => state.posts.status;
export const getPostsError = (state) => state.posts.error;

export const { postAdded, reactionAdded } = postsSlice.actions;

export default postsSlice.reducer;

## Explained

This code defines a Redux slice for managing a list of posts. It uses the `createSlice` and `createAsyncThunk` utilities from the `@reduxjs/toolkit` library to simplify the process of creating Redux actions, reducers, and handling asynchronous operations.

Let's break down the code:

1. **Import Statements:**

   ```javascript
   import { createSlice, nanoid, createAsyncThunk } from "@reduxjs/toolkit";
   import { sub } from "date-fns";
   import axios from "axios";
   ```

   The code imports necessary functions and libraries. `createSlice` and `createAsyncThunk` are from the Redux Toolkit, and `sub` is a function from the `date-fns` library for date manipulation. `axios` is a popular library for making HTTP requests.

2. **Constants:**

   ```javascript
   const POSTS_URL = "https://jsonplaceholder.typicode.com/posts";
   ```

   It defines the URL of a JSONPlaceholder endpoint representing posts.

3. **Initial State:**

   ```javascript
   const initialState = {
     posts: [],
     status: "idle", //'idle' | 'loading' | 'succeeded' | 'failed'
     error: null,
   };
   ```

   It sets the initial state for the Redux slice, including an empty array for posts, a status field indicating the current state of asynchronous operations, and an error field to store error messages.

4. **Async Thunks:**

   ```javascript
   export const fetchPosts = createAsyncThunk("posts/fetchPosts", async () => {
     // ...
   });

   export const addNewPost = createAsyncThunk(
     "posts/addNewPost",
     async (initialPost) => {
       // ...
     }
   );
   ```

   Two asynchronous thunks are defined using `createAsyncThunk`. `fetchPosts` fetches posts from the specified URL, and `addNewPost` adds a new post by making a POST request to the same URL.

5. **Slice Creation:**

   ```javascript
   const postsSlice = createSlice({
     name: "posts",
     initialState,
     reducers: {
       // ...
     },
     extraReducers(builder) {
       // ...
     },
   });
   ```

   The `createSlice` function is used to create a Redux slice named "posts." It defines an initial state, reducers, and extra reducers for handling asynchronous actions.

6. **Reducers:**

   ```javascript
   const postsSlice = createSlice({
     // ...
     reducers: {
       postAdded: {
         reducer(state, action) {
           state.posts.push(action.payload);
         },
         prepare(title, content, userId) {
           // ...
         },
       },
       reactionAdded(state, action) {
         // ...
       },
     },
     // ...
   });
   ```

   The `reducers` field contains two reducers: `postAdded` and `reactionAdded`. `postAdded` adds a new post to the state, and `reactionAdded` updates the reaction count of a specific post.

7. **Extra Reducers:**

   ```javascript
   extraReducers(builder) {
     builder
       .addCase(fetchPosts.pending, (state, action) => {
         // ...
       })
       .addCase(fetchPosts.fulfilled, (state, action) => {
         // ...
       })
       .addCase(fetchPosts.rejected, (state, action) => {
         // ...
       })
       .addCase(addNewPost.fulfilled, (state, action) => {
         // ...
       });
   }
   ```

   The `extraReducers` field handles additional actions like `fetchPosts.pending`, `fetchPosts.fulfilled`, `fetchPosts.rejected`, and `addNewPost.fulfilled`. It updates the state based on the status of these asynchronous operations.

8. **Selectors:**

   ```javascript
   export const selectAllPosts = (state) => state.posts.posts;
   export const getPostsStatus = (state) => state.posts.status;
   export const getPostsError = (state) => state.posts.error;
   ```

   Selector functions are defined to access specific parts of the state.

9. **Exports:**

   ```javascript
   export const { postAdded, reactionAdded } = postsSlice.actions;
   export default postsSlice.reducer;
   ```

   The code exports the action creators (`postAdded` and `reactionAdded`) and the reducer created by the `createSlice` function.
